### üß† ¬øPor qu√© usar **TypeScript** en lugar de solo **JavaScript**?

Aunque JavaScript funciona bien y lo usamos todo el tiempo, tiene un problema: **no nos avisa cuando cometemos errores hasta que el programa ya est√° corriendo**.

#### üëé JavaScript:
```js
let edad = "25";
console.log(edad * 2); // Resultado: 50 üò® ¬øpor qu√©? era un string
```

#### üëç TypeScript:
```ts
let edad: number = "25"; // ‚ùå Error: el string no se puede asignar a un number
```

---

### üöÄ Ventajas de TypeScript

1. ‚úÖ **Detecta errores antes de ejecutar**
   - Te avisa mientras escribes el c√≥digo.
   - Reduce bugs en producci√≥n.

2. üß© **Mejor experiencia en el editor (VSCode)**
   - Autocompletado inteligente.
   - Documentaci√≥n de funciones y objetos al instante.
   - Recomendaciones y refactorizaci√≥n m√°s f√°cil.

3. üßº **El c√≥digo es m√°s claro**
   - Si ves `nombre: string`, sabes lo que se espera.
   - Ayuda a otros (o a ti mismo en el futuro) a entender tu c√≥digo m√°s r√°pido.

4. üõ°Ô∏è **Es m√°s seguro**
   - Obliga a pensar qu√© tipo de datos manejamos.
   - Evita errores t√≠picos de pasar datos incorrectos entre funciones.

5. üß† **Preparaci√≥n para proyectos reales**
   - La mayor√≠a de aplicaciones React en empresas usan TypeScript.
   - Cada vez m√°s equipos lo exigen por productividad y mantenimiento.

---

### üéØ En resumen:
> **TypeScript no reemplaza a JavaScript**, lo mejora.
>  
> Es como tener un amigo que te corrige antes de que el profesor vea tu tarea ‚úèÔ∏è



---
#### üëé Restaurante de Hamburguesas:
 1. Empecemos con un men√∫ de hamburguesas `menu`, una variable para guardar el dinero en la caja registradora `cashInRegistry` (siempre va a empezar con $100) y una variable para registrar las ordenes en curso `orderQueue`.
   ```js
     menu = [
        { name: 'Supreme', price: 10},
        { name: 'Deluxe', price: 12},
        { name: '1/4 pound with cheese', price: 13},
        { name: 'Classic', price: 14},
        { name: 'Extreme', price: 14},
        { name: 'Salty Crunch', price: 9}
      ]
      
      cashInRegistry = 100;
      orderQueue = [];
   ```
 2. CHALLENGE: Crea una funci√≥n llamada `addNewHamburguer` que reciba un objeto de tipo hamburguesa y la a√±ada al men√∫
 3. CHALLENGE: Crea una funci√≥n llamada `placeOrder` que reciba el nombre de una hamburguesa como par√°metro:
    - Buscar el objeto de hamburguesa en el men√∫
    - Agregar un nuevo objeto de tipo orden a la lista de   `orderQueue`. Ej: `{'hamburguer': ObjetodeHamburguesa, status: 'ordered'}`
    - Retornar el nuevo objeto de orden
4. CHALLENGE: Desaf√≠o: escribe otra funci√≥n llamada `completeOrder` que reciba un `orderId` como par√°metro,
   busque la orden correspondiente en la cola de √≥rdenes (`orderQueue`), y marque su estado como "completed".
   Para mayor utilidad, retorna la orden encontrada desde la funci√≥n.

   Nota: debes asegurarte de que estemos agregando IDs a nuestras √≥rdenes cuando se crean nuevas √≥rdenes.
   Puedes usar una variable global llamada `nextOrderId` e incrementarla cada vez que se cree una nueva orden
   para simular c√≥mo una base de datos nos asignar√≠a IDs reales.
5. 

